(async () => {
  let animating = true;
  const loadingFrames = ["Scanning.  ", "Scanning.. ", "Scanning..."];
  let frame = 0;

  const spinner = setInterval(() => {
    console.clear();
    console.log(loadingFrames[frame % loadingFrames.length]);
    frame++;
  }, 400);

  const patterns = [
    {
      type: 'Generic Secret',
      regex: /['"`][A-Za-z0-9_\-]{16,}['"`]/g,
      severity: 'medium',
      explanation: 'Hardcoded secrets can be harvested by attackers for unauthorized access to APIs, services, or infrastructure.'
    },
    {
      type: 'API Key',
      regex: /api[_-]?key['"`]?\s*[:=]\s*['"`][A-Za-z0-9_\-]{8,}['"`]/gi,
      severity: 'extreme',
      explanation: 'API Keys found in client code can be abused by attackers to access backend systems, potentially incurring costs or data breaches.'
    },
    {
      type: 'Secret',
      regex: /secret['"`]?\s*[:=]\s*['"`][A-Za-z0-9_\-]{8,}['"`]/gi,
      severity: 'extreme',
      explanation: 'Exposed secrets often grant direct access to sensitive resources or systems, leading to account or data compromise.'
    },
    {
      type: 'Token',
      regex: /token['"`]?\s*[:=]\s*['"`][A-Za-z0-9_\-]{8,}['"`]/gi,
      severity: 'extreme',
      explanation: 'Tokens can be used to impersonate users or services, resulting in privilege escalation or data exfiltration.'
    },
    {
      type: 'Password',
      regex: /password['"`]?\s*[:=]\s*['"`][^'"`]{4,}['"`]/gi,
      severity: 'extreme',
      explanation: 'Plaintext passwords may allow attackers to directly log in to services or escalate privileges.'
    },
    {
      type: 'AWS Access Key',
      regex: /AKIA[0-9A-Z]{16}/g,
      severity: 'extreme',
      explanation: 'AWS Access Keys can allow attackers to fully control cloud resources and access sensitive data.'
    },
    {
      type: 'Google API Key',
      regex: /AIza[0-9A-Za-z\-_]{35}/g,
      severity: 'extreme',
      explanation: 'Google API Keys can be abused for quota exhaustion or access to Google Cloud resources.'
    },
    {
      type: 'Google OAuth',
      regex: /ya29\.[0-9A-Za-z\-_]+/g,
      severity: 'extreme',
      explanation: 'OAuth tokens can be used to access or impersonate user accounts and sensitive data.'
    },
    {
      type: 'GitHub Token',
      regex: /ghp_[0-9A-Za-z]{36}/g,
      severity: 'extreme',
      explanation: 'GitHub tokens can allow attackers to push malicious code or steal sensitive repository data.'
    },
    {
      type: 'Insecure Resource (HTTP)',
      regex: /src=['"]http:\/\/[^'"]+/gi,
      severity: 'medium',
      explanation: 'HTTP resources can be intercepted or modified in transit (man-in-the-middle attacks).'
    },
    {
      type: 'Exposed Credentials in URL',
      regex: /https?:\/\/[^\s\/]+:[^\s\/]+@/gi,
      severity: 'extreme',
      explanation: 'Credentials in URLs can be easily harvested from browser history or server logs.'
    },
    {
      type: 'Inline Event Handler',
      regex: /on\w+=['"][^'"]+['"]/gi,
      severity: 'medium',
      explanation: 'Inline event handlers can introduce XSS vulnerabilities if user data is injected.'
    },
  ];

  async function fetchAndScan(url, context) {
    try {
      const res = await fetch(url);
      if (!res.ok) return [];
      const text = await res.text();
      return scanText(text, url, context);
    } catch {
      return [];
    }
  }

  function scanText(text, location, context) {
    let findings = [];
    patterns.forEach(({ type, regex, severity, explanation }) => {
      let match;
      while ((match = regex.exec(text))) {
        findings.push({
          type,
          match: match[0],
          location,
          context,
          severity,
          explanation,
        });
      }
    });
    return findings;
  }

  let sources = [];

  sources.push({ type: 'html', content: document.documentElement.outerHTML, location: document.location.href });

  document.querySelectorAll('script:not([src])').forEach((el, i) => {
    sources.push({
      type: 'inline-script',
      content: el.textContent,
      location: `${document.location.href} (inline script #${i + 1})`
    });
  });

  document.querySelectorAll('*').forEach((el) => {
    Array.from(el.attributes).forEach(attr => {
      if (attr.name.startsWith('on')) {
        sources.push({
          type: 'inline-event',
          content: attr.value,
          location: `${document.location.href} (<${el.tagName.toLowerCase()} ${attr.name}="...">)`
        });
      }
    });
  });

  const externalSelectors = [
    { tag: 'script', attr: 'src' },
    { tag: 'link[rel="stylesheet"]', attr: 'href' },
    { tag: 'iframe', attr: 'src' },
    { tag: 'img', attr: 'src' }
  ];
  let externalUrls = [];
  externalSelectors.forEach(({ tag, attr }) => {
    document.querySelectorAll(tag).forEach(el => {
      const url = el.getAttribute(attr);
      if (url && url.startsWith('https://')) {
        externalUrls.push({ url, context: `<${el.tagName.toLowerCase()} ${attr}="${url}">` });
      }
      if (url && url.startsWith('http://')) {
        sources.push({
          type: 'insecure-resource',
          content: url,
          location: document.location.href,
        });
      }
    });
  });

  function getVisibleText() {
    let walker = document.createTreeWalker(document.body, NodeFilter.SHOW_TEXT, {
      acceptNode: (node) => {
        if (!node.parentElement || !node.textContent.trim()) return NodeFilter.FILTER_REJECT;
        const style = window.getComputedStyle(node.parentElement);
        return style && style.display !== 'none' && style.visibility !== 'hidden'
          ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_REJECT;
      }
    });
    let text = "", node;
    while (node = walker.nextNode()) text += node.textContent + "\n";
    return text;
  }
  sources.push({ type: 'visible-text', content: getVisibleText(), location: document.location.href });

  let findings = [];
  for (const src of sources) {
    findings.push(...scanText(src.content, src.location, src.type));
  }

  for (const ext of externalUrls) {
    findings.push(...await fetchAndScan(ext.url, ext.context));
  }

  const hazards = findings.filter(f =>
    f.severity === 'extreme' || f.severity === 'medium'
  );

  clearInterval(spinner);
  console.clear();
  console.log('Scanned.');

  if (findings.length === 0) {
    console.log("✅ No secrets or security weaknesses found.");
    return;
  }

  console.groupCollapsed(`🕵️ Security Findings (${findings.length}) — click to expand`);
  findings.forEach(f =>
    console.log(
      `🔸 [${f.type}]\n    Match: ${f.match}\n    Location: ${f.location}\n    Context: ${f.context || ""}\n`
    )
  );
  console.groupEnd();

  if (hazards.length > 0) {
    console.groupCollapsed(`⚠️ Potentially Exploitable Hazards (${hazards.length}) — click to expand`);
    hazards.forEach(f =>
      console.log(
        `🚨 [${f.type.toUpperCase()}] [${f.severity.toUpperCase()}]\n    Match: ${f.match}\n    Location: ${f.location}\n    Context: ${f.context || ""}\n    Exploitation: ${f.explanation}\n`
      )
    );
    console.groupEnd();
  }
})();
